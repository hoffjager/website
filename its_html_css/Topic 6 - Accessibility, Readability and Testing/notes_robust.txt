Topic 6 - Accessibility, Readability & Testing

Overview
6.1 Construct well-formed HTML and CSS markup that conforms to industry
    best practices: 
        Reusing rules and rule sets, commenting, web-safe fonts,
        cross-platform usability, separation of structure (HTML) and
        style (CSS). 

6.2 Apply accessibility principles and evaluate content accessibility:
        Text alternatives, color contrast and usage, legibility of
        typography, tab order, text resizing, text hierarchy, translate. 

6.3 Evaluate the structural integrity of HTML and CSS markup:
        Syntax errors, tag mismatch, cascading issues.

Reading Material
Bullet Points on Web Content Accessibility Guidelines (WCAG) 2.1 at a
Glance (E/L):
https://www.w3.org/WAI/standards-guidelines/wcag/glance/
https://www.w3.org/TR/WCAG21/

Links:
WCAG 2.1 Overview
How to Meet WCAG 2.1 (Quick Reference)

Principle 4 - Robust
    Content must be robust enough that it can be interpreted by a wide variety of user agents, including assistive technologies.
    Guideline 4.1 - Compatible
        Maximize compatibility with current and future user agents, including assistive technologies.
        4.1.1 Parsing - Level A
            In content implemented using markup languages, elements have complete start and end tags, elements are nested according to their specifications, elements do not contain duplicate attributes, and any IDs are unique, except where the specifications allow these features.
            Note 1: Start and end tags that are missing a critical character in their formation, such as a closing angle bracket or a mismatched attribute value quotation mark are not complete.
            Understanding 4.1.1
            Sufficient Techniques
            Note: Other techniques may also be sufficient if they meet the success criterion. See Understanding Techniques.
                G134: Validating Web pages
                G192: Fully conforming to specifications
                H88: Using HTML according to spec
                Ensuring that Web pages can be parsed by using one of the following techniques:
                    H74: Ensuring that opening and closing tags are used according to specification AND H93: Ensuring that id attributes are unique on a Web page AND H94: Ensuring that elements do not contain duplicate attributes
                    H75: Ensuring that Web pages are well-formed 
                SL33: Using Well-Formed XAML to Define a Silverlight User Interface
            Failures
                F70: Failure of Success Criterion 4.1.1 due to incorrect use of start and end tags or attribute markup
                F77: Failure of Success Criterion 4.1.1 due to duplicate values of type ID
        4.1.2 Name, Role, Value - Level A
            For all user interface components (including but not limited to: form elements, links and components generated by scripts), the name and role can be programmatically determined; states, properties, and values that can be set by the user can be programmatically set; and notification of changes to these items is available to user agents, including assistive technologies.
            Note 1: This success criterion is primarily for Web authors who develop or script their own user interface components. For example, standard HTML controls already meet this success criterion when used according to specification.
            Understanding 4.1.2
            Sufficient Techniques
            Note: Other techniques may also be sufficient if they meet the success criterion. See Understanding Techniques.
            Situation A: If using a standard user interface component in a markup language (e.g., HTML):
                ARIA14: Using aria-label to provide an invisible label where a visible label cannot be used
                ARIA16: Using aria-labelledby to provide a name for user interface controls
                G108: Using markup features to expose the name and role, allow user-settable properties to be directly set, and provide notification of changes
                    H91: Using HTML form controls and links
                    H44: Using label elements to associate text labels with form controls
                    H64: Using the title attribute of the frame and iframe elements
                    H65: Using the title attribute to identify form controls when the label element cannot be used
                    H88: Using HTML according to spec
            Situation B: If using script or code to re-purpose a standard user interface component in a markup language:
                Exposing the names and roles, allowing user-settable properties to be directly set, and providing notification of changes using one of the following techniques:
                    ARIA16: Using aria-labelledby to provide a name for user interface controls
            Situation C: If using a standard user interface component in a programming technology:
                G135: Using the accessibility API features of a technology to expose names and notification of changes
                    FLASH32: Using auto labeling to associate text labels with form controls
                    FLASH29: Setting the label property for form components
                    FLASH30: Specifying accessible names for image buttons
                    PDF10: Providing labels for interactive form controls in PDF documents
                    PDF12: Providing name, role, value information for form fields in PDF documents
                    SL26: Using LabeledBy to Associate Labels and Targets in Silverlight
                    SL32: Using Silverlight Text Elements for Appropriate Accessibility Role
            Situation D: If creating your own user interface component in a programming language:
                G10: Creating components using a technology that supports the accessibility notification of changes
                    ARIA4: Using a WAI-ARIA role to expose the role of a user interface component
                    ARIA5: Using WAI-ARIA state and property attributes to expose the state of a user interface component
                    ARIA16: Using aria-labelledby to provide a name for user interface controls
                    SL6: Defining a UI Automation Peer for a Custom Silverlight Control
                    SL18: Providing Text Equivalent for Nontext Silverlight Controls With AutomationProperties.Name
                    SL20: Relying on Silverlight AutomationPeer Behavior to Set AutomationProperties.Name
                    SL30: Using Silverlight Control Compositing and AutomationProperties.Name
            Failures
                F59: Failure of Success Criterion 4.1.2 due to using script to make div or span a user interface control in HTML without providing a role for the control
                F15: Failure of Success Criterion 4.1.2 due to implementing custom controls that do not use an accessibility API for the technology, or do so incompletely
                F20: Failure of Success Criterion 1.1.1 and 4.1.2 due to not updating text alternatives when changes to non-text content occur
                F68: Failure of Success Criterion 4.1.2 due to a user interface control not having a programmatically determined name
                F79: Failure of Success Criterion 4.1.2 due to the focus state of a user interface component not being programmatically determinable or no notification of change of focus state available
                F86: Failure of Success Criterion 4.1.2 due to not providing names for each part of a multi-part form field, such as a US telephone number
                F89: Failure of Success Criteria 2.4.4, 2.4.9 and 4.1.2 due to not providing an accessible name for an image which is the only content in a link
        4.1.3 Status Messages - Level AA (Added in 2.1)
            In content implemented using markup languages, status messages can be programmatically determined through role or properties such that they can be presented to the user by assistive technologies without receiving focus.
            Understanding 4.1.3
            Sufficient Techniques
            Note: Other techniques may also be sufficient if they meet the success criterion. See Understanding Techniques.
            Situation A: If a status message advises on the success or results of an action, or the state of an application:
                ARIA22: Using role=status to present status messages
                    G199: Providing success feedback when data is submitted successfully
            Situation B: If a status message conveys a suggestion, or a warning on the existence of an error:
                ARIA19: Using ARIA role=alert or Live Regions to Identify Errors
                G83: Providing text descriptions to identify required fields that were not completed
                G84: Providing a text description when the user provides information that is not in the list of allowed values
                G85: Providing a text description when user input falls outside the required format or values
                G177: Providing suggested correction text
                G194: Providing spell checking and suggestions for text input 
            Situation C: If a status message conveys information on the progress of a process:
                ARIA23: Using role=log to identify sequential information updates
                Using role="progressbar" (future link)
                ARIA22: Using role=status to present status messages AND G193: Providing help by an assistant in the Web page
            Advisory Techniques
                Using aria-live regions with chat clients (future link)
                Using role="marquee" (future link)
                Using role="timer" (future link)
                ARIA18: Using aria-alertdialog to Identify Errors
                SCR14: Using scripts to make nonessential alerts optional
            Failures
                Using role="alert" or aria-live="assertive" on content which is not important and time-sensitive (future link)
                Using a visibilitychange event to hide or display a document without switching the document's live regions between active and inactive (future link)