Topic 5 - Webpage Styling using CSS

Topic Overview:

5.1 Construct and analyze styles that position content:
Positioning (float, relative, absolute, static, and fixed) max-width, overflow, height, width, align, display, inline vs. block, visibility, box model,
margins and padding. 

5.2 Construct and analyze styles that format text:
font-family, color, font-style, font-size, font-weight, font-variant, link colors, text formatting, text alignment, text decoration, indentation,
line-height, word-wrap, and letter-spacing.

5.3 Construct and analyze styles that format backgrounds and borders:
border-color, border-style, border-width, background properties, colors.

5.4 Construct and analyze styles that create a simple responsive layout:
Units of measurement (percentages, pixels, em, vw, vh), viewport and media query, frameworks and templates, working with breakpoints, grids.

Chapter 3: Styling Boxes
	Recognizing Content Boxes
	Changing Display Formats
	Sizing the Content Area
	Controlling Borders
	Adding Padding
	Setting Margins
	Painting Colors
	Repeating Backgrounds
	Positioning Backgrounds
	Summary

	Recognizing Content Boxes
Content on a web page is displayed in a number of invisible rectangular
boxes that are generated by the browser. These content boxes may be either
"block level" or "inline".
Block-level content boxes normally have line breaks before and after the
box, such as paragraph, heading and "div" elements.
Inline content boxes, on the other hand, do not add line breaks but are
simply created within lines of text, such as span, emphasis, and hyperlink
elements.
Each block-level content box comprises a core content area surrounded by
optional areas for padding, border, and margins.
Style rules can specify values for the padding, border, and margin properties
to control the appearance of content boxes.
These all apply to block-level boxes but some properties, such as width
and height, do not apply to inline boxes. Additionally, the margin and
padding properties of inline boxes only apply to either side of the
content – not the areas above and below the content.
Block-level content boxes are by default stacked on the page, one below
another, whereas inline content boxes appear within a blocklevel box, one
behind another.
When the padding, border, and margin properties all have a zero width the
content box will be the same size as the content area, determined by the
dimensions of the content.
Any padding, border, and margin areas that have a non-zero width are added
outside the content area, so the content size remains the same but the box
size increases.
The padding property extends the area around the content and inherits the
background color of the content area. The border property extends the area
around the content and any padding. The margin property extends the area
around the content, any padding, and any border, with a transparent background.

Refer to:
box.html
&
box.css

	Changing Display Formats
A web page relies upon the creation of block-level content boxes, to
determine its general layout, and the creation of inline content boxes
within the blocks to determine its precise layout.
This places great emphasis on whether an element is considered block-level
or inline to determine the display format.
Generally the default display format for each element will be the most
appropriate. For example, it's generally desirable to display list items
on individual lines in a block-level list.
The run-in and inline-block styles are not universally supported, so it
may be best to avoid them. They are included here for completeness.
The display format of an element can also be explicitly determined by a
style rule that assigns the block or inline keywords to that element's
display property. This means that content can be displayed in a different
format without changing the HTML tags. For example, list items can be
displayed on a single line with a display : inline declaration.
Where two block-level elements follow each other the first can be made to
be displayed as if it was an inline box within the beginning of the second
block by assigning its display property the run-in keyword. For example,
applying a run-in style rule to a heading that is followed by a paragraph
will display the heading apparently within the start of the paragraph block.
Additionally an inline content-box can have its display property assigned
an inline-block value to allow it to be displayed somewhat like a
block-level content box. The inline-block still appears inline, as usual,
but unlike regular inline content boxes its width and height properties
can be assigned values to control its size.

Refer to:
display.html
&
display.css

	Sizing the Content Area
When assigning any non-zero value to a property the declaration must
include a two-letter unit name to specify which unit of measurement to
apply. The CSS specification provides the following unit names representing
real world measurement:

inches:
	div {width: 1in}
centimeters, 2.54cm = 1 inch:
	div {height: 2.54cm}
millimeters, 1/10 of 1cm, 25.4mm = 1 inch:
	div {height: 25.4mm}
pt(points), font height where 72 points = 1 inch:
	div {font-size: 72pt}
pc(picas): font height where 6 picas = 1 inch:
	div {font-size: 6pc}

Zero values can be assigned using just a "0" number – without specifying
a unit name.

The CSS specification also provides the following unit names representing
relative values according to the viewing device:

em(fontsize):
Font size where 1em is equivalent to the height of a given font:
	div {font-size: 14pt}
	(1em = 14pt)
ex(fontsize):
Font size where 1ex is equivalent to the height of lowercase "x" in a
font (often 50% of 1em):
	div {font-size: 14pt}
	(1ex = 7pt)
px(pixels):
Representing the dots on a computer monitor where there are 1024 pixels
on each line when the monitor resolution is 1024×768:
	div {height: 100px}
A percentage value can also specify a relative size – where a value of
50% makes the target element half the size of its containing element.

Refer to:
size.html
&
size.css

	Controlling Borders
Each content box can have a border comprising border-width, border-color,
and border-style properties. A value can be specified to each of these
individual properties to apply a uniform border to all four sides of the
content box, or a spaceseparated list of values can be specified to apply
different borders to each side:

When two values are listed the first is applied to the top and bottom
borders.
When three values are listed the first is applied to the top border, the
second is applied to the left and right borders, and the third is applied
to the bottom border.
When four values are listed they are applied clockwise to the top, right,
bottom, and left borders.

The default border-width value is medium (a computed value), and the
default border-color value is inherited from the element's color property,
but the default border-style is none. This means that the border will not
be visible until a value is assigned – possible border-style values are
solid, double, dotted, dashed, groove, ridge, inset, outset, hidden, and
none.
Rather than creating separate style rules for the border-width,
border-color, and border-style properties it is simpler to use the CSS
shorthand technique that specifies a value for each of these three properties
to a border property as a spaceseparated list. This uniformly styles each
side of the content box with a border of the specified width, color, and
style. For example, a style rule declaration of border: 0.5in red dotted
would apply a half-inch wide red dotted border to all four sides of the
content box.
The outset border style can be used to create the appearance of a raised
button – and the inset border style can be used to create the appearance
of a depressed button.
If it is desirable to have different styles, the borders on each side of
a content box can be individually styled by creating rules for the
element's border-top, border-right, border-bottom, and border-left
properties. The CSS shorthand technique can also be used with these
properties to specify a width, color, and style for the individual side
as a space-separated list. For example, a style rule declaration of
border-bottom: 0.5in red dotted would apply a half-inch wide red dotted
border to just the bottom side of the content box.

Refer to:
borders.html
&
borders.css

	Adding Padding
Each content box can have "padding" space added around the core content
area by a style rule assigning a value to the padding property. A single
value can be specified to apply a uniform padding width to all four sides
of the content area, or a space-separated list of values can be specified
to apply different padding widths to each side:
When two values are listed the first is applied to the top and bottom
sides and the second is applied to the left and right.
When three values are listed the first is applied to the top side, the
second is applied to the left and right sides, and the third is applied
to the bottom side.
When four values are listed they are applied clockwise to the top, right,
bottom, and left sides.
Setting padding as a percentage may produce undesirable results when the
user resizes the browser window – specify unit values to avoid this.
The padding area surrounds the core content area and extends to the outer
edges of the border area if a border is specified – right up to the
beginning of the margin area. The element's background fills the core
content area and the padding area, so that any specified background color
gets automatically applied to both the core content area and the padding
area.
The padding property can be specified as a unit value or as a percentage
value. When a percentage is specified the padding width is calculated using
the width and height of the containing element and the padding area size
will be adjusted if the size of the containing element gets changed.
The padding width for each side can be set using the CSS padding
shorthand by setting sides requiring no padding to zero – always use
the shorthand.
Typically a padding area is specified when adding a border to an element
to increase the space between the content and the border.
If it is desirable to have different padding widths on each side of a
content box the padding can be individually styled by creating rules for
the element's padding-top, padding-right, padding-bottom, and padding-left
properties. For example, style rule declarations of:
padding-top : 0.5in; padding-bottom : 0.5in would apply a half-inch
padding area to top and bottom sides.
Alternatively, the same result can be achieved using the CSS shorthand
with a declaration of:
padding : 0.5in 0 0.5in 0

Refer to:
padding.html
&
padding.css

	Setting Margins
Each content box can have outer "margin" space added around the entire
content, padding, and border areas by a style rule assigning a value to
the margin property. A single value can be specified to apply a uniform
margin width to all four sides of the content box, or a space-separated
list of values can be specified to apply different margin widths to each
side:
When two values are listed the first is applied to the top and bottom
sides and the second is applied to the left and right.
When three values are listed the first is applied to the top side, the
second is applied to the left and right sides, and the third is applied
to the bottom side.
When four values are listed they are applied clockwise to the top, right,
bottom, and left sides.
The ability to automatically compute the margin size is essential for
centering content.
The margin property has a default value of zero but in reality the
browser applies its own intrinsic default values to allow spacing between
elements. For example, heading elements always allow a margin area before
a following paragraph element.
The margin property can be specified as a unit value, or as a percentage
value, or with the auto keyword to have the browser compute a suitable
margin.
Margins do not inherit any background and are always transparent – they
merely separate elements by a specified distance.
The margin width for each side can be set using the CSS margin shorthand
by setting sides requiring no margin to zero – always use the shorthand.
If it is desirable to have different margin widths on each side of a
content box the margin can be individually styled by creating rules for
the element's margin-top, margin-right, margin-bottom, and margin-left
properties. For example, style rule declarations of:
margin-top : 0.5in; margin-bottom : 0.5in would apply a half-inch margin
area to top and bottom sides.
Alternatively, the same result can be achieved using the CSS shorthand
with a declaration of:
margin : 0.5in 0 0.5in 0

Refer to:
margin.html
&
margin.css

	Painting Colors
The listed examples so far in this book have employed color keywords to
represent the 17 CSS "standard" colors as below:
Red,Purple,Fuchsia,Maroon,Orange,
Green,Lime,Olive,Yellow,
Blue,Aqua,Navy,Teal,
Black,Silver,Gray,White
While the standard named colors are convenient to use they provide only
a limited choice. Fortunately CSS allows authors to create their own
custom colors.
Each color can be defined by the amount of red, green, and blue that
needs to be mixed together to form that particular color.
For example, the standard olive color comprises 50% red, 50% green and
0% blue. This can be expressed in RGB notation form as rgb(50%, 50%, 0%)
for assignment to a CSS property like this:
h1 {color: rgb(50%,50%,0%)} /* Olive headings */
Specifying different amounts of red, green, and blue, in this way the
author can assign to a property any custom color desired.
As an alternative to specifying each color component as a percentage the
author may choose an integer value in the range 0-255 for each component.
In this format the RGB notation for the standard olive color looks like
this:
h1 {color: rgb(128,128,0)} /* Olive headings */
Web browsers often recognize many more color names (often up to 140) but
those shown here are the standard color names defined in the CSS
specifications.
A second alternative to specifying each color component as a percentage
allows the author to choose a hexadecimal value in the range 00-FF for
each component. In this format the assignment for the standard olive
color looks like this:
h1 {color: #808000} /* Olive headings */
The table opposite lists the ways in which each standard color can be
assigned to a property using these various methods:
Color  Percentage	Integer		Hex
Black rgb(0%,0%,0%) rgb(0,0,0) #000000
Red rgb(100%,0%,0%) rgb(255,0,0) #FF0000
Orange rgb(100%,65%,0%) rgb(255,165,0) #FFA500
Yellow rgb(100%,100%,0%) rgb(255,255,0) #FFFF00
Fuchsia rgb(100%,0%,100%) rgb(255,0,255) #FF00FF
Lime rgb(0%,100%,0%) rgb(0,255,0) #00FF00
Aqua rgb(0%,100%,100%) rgb(0,255,255) #00FFFF
Blue rgb(0%,0%,100%) rgb(0,0,255) #0000FF
White rgb(100%,100%,100%) rgb(255,255,255) #FFFFFF
Maroon rgb(50%,0%,0%) rgb(128,0,0) #800000
Olive rgb(50%,50%,0%) rgb(128,128,0) #808000
Purple rgb(50%,0%,50%) rgb(128,0,128) #800080
Green rgb(0%,50%,0%) rgb(0,128,0) #008000
Teal rgb(0%,50%,50%) rgb(0,128,128) #008080
Navy rgb(0%,0%,50%) rgb(0,0,128) #000080
Gray rgb(50%,50%,50%) rgb(128,128,128) #808080
Silver rgb(75%,75%,75%) rgb(192,192,192) #C0C0C0
Hexadecimal color values comprising three pairs of matching digits can
alternatively be expressed using CSS shorthand notation that represents
each pair of digits as a single digit. For example, the hexadecimal value
for the standard red color is #FF0000 but can be specified in shorthand
as #F00. Similarly black #000000 can be written as #000 and white #FFFFFF
as #FFF.
In hex notation, you can specify "web safe" consistent colors by using
only digits that are multiples of 3 for the red, green and blue.
The author is free to choose which color notation method to use according
to their preference. Declarations in the style rules below show how each
method might be used to specify a custom color:
h1 {color: rgb(85%,15%,0%)} /* A custom red */
h2 {color: rgb(0,192,12)} /* A custom green */
h3 {color: #042BDF} /* A custom blue */
h4 {color: #DE2} /* A custom yellow (#DDEE22) */

Refer to:
colors.html
&
colors.css

	Repeating Backgrounds
Each content box can have a background color specified by assigning a
valid color value to its background property.
Alternatively an image can be specified for the background by assigning
a url(filename) value, where filename is the path to an image file – this
should not be enclosed within quotes.
The background-color and background-image properties can be used to
specify both a background color and a background image. Any specified
background image will normally be positioned at the top left corner of
the content box. The default behavior of the browser's background-repeat
property is set to repeat so the image will be tiled, row-by-row, across
the content box.
Use the background property shorthand rather than the various individual
properties – to keep the style sheet more concise.
The tiling behavior can be modified by assigning different values to the
background-repeat property where values of repeatx restricts the tiling
pattern to one horizontal row and repeat-y restricts the tiling pattern
to one vertical column. Tiling can also be prevented by assigning a
no-repeat value so that a single copy of the image appears at the top
left corner of the content box.
Background images are placed on a layer above the background's color
layer so specifying an image with transparent areas will allow the
background color to shine through.
Using CSS shorthand the color, image, and repeat values can simply be
assigned as a space-separated list to the background property. These may
appear in any order and default values are assumed for any value not
specified in the list.
For example, the background-repeat property is assumed to have a repeat
value unless another value is specified.

Refer to:
background.html
&
background.css

	Positioning Backgrounds
A background image is, by default, positioned at the top left corner of
the content box but this can be modified by specifying a different value
to the background-position property. This can accept keywords of either
left, center, right, top, and bottom.
Two of these keywords may be used to specify the position, separated by
a space, such as top center. Alternatively just one of these keywords
can be specified and the second value will be assumed to be center.
The background-position property can also be assigned percentage values
to specify the position with greater precision, taken from the dimensions
of the containing element. The keywords have the equivalent to these
percentages:
X-Axis:							 Y-Axis:
								 top(0%)
left(0%) center(50%) right(100%) center(50%)
								 bottom(100%)
When specifying position with percentages the first value sets the X-axis
position and the second value sets the Y-axis position.
If only one percentage is specified the second is assumed to be 50%.
Interestingly, when computing the background image position the browser
first identifies a point within the image at the specified coordinates,
then places that point at the same coordinates within the content box.
For example, with values of 50% 50% the browser first identifies a point
at the exact center of the image then places that point at the exact
center of the content box.
The background-position property can also accept unit values to specify
an offset position of the top left corner of the image from the top left
corner of the content box. But this is only useful where the size of the
content box cannot change – use keywords or percentages for greater
flexibility.
The background-attachment property has a scroll value by default so the
background image scrolls with the page but a style rule can specify a
fixed value so it remains at specified coordinates relative to the
viewport when the page gets scrolled.
Both background-position and background-attachment property values can
be specified to the CSS background property, along with the
background-color, background-image, and background-repeat values
described in the previous section.

Refer to:
position.html
&
position.css

	Summary
(.) Block-level content boxes add line breaks before and after the box –
but inline content boxes appear within lines of text.
(.) The core content area of a content box can be surrounded by padding,
border, and margin areas.
(.) A content box's display property can be used to change its display
format from block-level to inline, and vice versa.
(.) Content box dimensions can be specified to width and height
properties as absolute values of in, cm, mm, pt, and pc units, or as
relative values of em, ex, and px measurements.
(.) The border property can specify the individual border-width,
border-color, and border-style properties using CSS shorthand.
(.) Border styles may be solid, double, dotted, dashed, groove, ridge,
inset, outset, hidden or none.
(.) The padding property can specify the individual padding-top,
padding-right, padding-bottom, and padding-left properties using CSS
shorthand.
(.) The margin property can specify the individual margin-top,
margin-right, margin-bottom, and margin-left properties using CSS
shorthand.
(.) Colors can be specified using the standard color keywords, or as a
three-part rgb() value with percentage or numerical parts, or as a
single hexadecimal value.
(.) The background property can specify the individual background-color,
background-image, background-repeat, background-position, and
background-attachment properties using CSS shorthand.
(.) Background images can be specified as a url() value in which the
path to the image file is stated within the parentheses.

Chapter 4: Controlling Layout
	Centering Content Boxes
	Positioning Boxes Absolutely
	Stacking Content Boxes
	Positioning Boxes Relatively
	Fixing Constant Positions
	Floating Content Boxes
	Clipping & Handling Overflow
	Constructing Columns
	Summary

	Centering Content Boxes
One of the basic requirements in displaying document components is the
ability to horizontally center blocks of content – in the same way
provided by the old HTML <center> tag.
In CSS the ability to horizontally center block-level elements is
provided by the margin property and the auto keyword.
Assigning an auto value to the margin property removes top and bottom
margins – just as if they had been assigned a zero value.
When the auto keyword is specified to an element's margin property the
browser first calculates the distance to the left and right of that
element, up to the boundaries of its containing element, then divides the
total in half to compute the value of each side margin. For example,
applying a margin : auto to a "div" element of 80px width, that is
contained within an outer element of 200px width, the browser divides the
total difference of 120px in half then applies 60px wide margins to each
side of the div element – so it gets positioned centrally within the
containing element.
Notice that margin : auto does not center vertically but merely sets the
top and bottom margins to zero, so there are no margin areas above or
below the element block.
It is important to recognize that margin : auto centers block-level
content boxes and should not be confused with text-align : center that
can be used to center content within inline content boxes.

Refer to:
center.html
&
center.css

	Positioning Boxes Absolutely
When laying out the element content boxes of a web page the CSS position
property has a default value of static – representing the normal flow
positioning scheme. Assigning a different value to an element's position
property allows that element to be removed from the normal flow so it
can be positioned independently.
Alternatives to the default static value can be specified using the
absolute, relative, and fixed keywords to specify an alternative
positioning scheme to that of the normal flow layout.
Each outer content box remains at its absolute position to the window
when the browser window gets resized.
The absolute, relative, and fixed positioning schemes each use one or
more of the CSS "offset" properties top, right, bottom, and left, to
define their position.
When the position property is specified as absolute the positioning
scheme places the element at the specified offset distance from the
boundaries of its containing element. For example, a "div" element with
top and left values of 100px will be positioned 100px below and to the
right of its container boundaries.

Refer to:
absolute.html
&
absolute.css

	Stacking Content Boxes
Changing from the static default positioning scheme, by assigning the
absolute value to the position property, allows elements to overlap –
stacking one above the other in the same order they are listed in the
HTML code.
The stacking order can be explicitly specified, however, in CSS by
assigning an integer value to the z-index property of each element.
The element with the highest value appears uppermost, then beneath that
appears the element with the next highest value, and so on.
"Viewport" is simply another name for the browser window.
So the absolute positioning scheme allows the element position to be
precisely controlled in three dimensions using XYZ coordinates – along
the X axis with the left and right offset properties, along the Y axis
using the top and bottom offset properties, and along the Z axis using
the z-index stacking order property.

Refer to:
stack.html
&
stack.css

	Positioning Boxes Relatively
In contrast to the absolute positioning scheme, which entirely removes
an element from the normal flow layout, a relative positioning scheme
adjusts the position of an element relative to the position it would
originally occupy in the normal flow layout.
Changing from the default static positioning scheme, by assigning the
relative value to the CSS position property, allows elements to be
repositioned from their normal flow layout position using the offset
properties top, right, bottom and left.
Notice how a negative value is used here – these can be used with other
properties too but may sometimes produce unexpected results.
For example, specifying a top value of −18px moves the selected element
up and specifying a left value of 100px moves it to the right – but
crucially the space occupied by its original layout position is
preserved. Applying these relative position values to a span element
within a paragraph has this effect.
Notice how the original content is shifted from its normal flow layout
position into a newly-created content box positioned at the specified
distance relative to its original position. This relative position will
be maintained, even when the position of the outer containing element is
changed.
So while absolute positioning may typically control the position of the
outer element the relative positioning scheme is often useful to control
the position of nested inner elements.

Refer to:
relative.html
&
relative.css

	Fixing Constant Positions
A fixed positioning scheme, like the absolute positioning scheme,
completely removes the selected element's content box from the normal
flow layout. But unlike absolute positioning, where offset values relate
to the boundaries of the containing element, in fixed positioning the
offset values relate to the viewport – the position is relative to the
browser window, not to any part of the document.
Usefully, element positions can be fixed to emulate a frame-style
interface where some frames remain at a constant position regardless of
how the regular page is scrolled. For example, a banner header frame can
be fixed at the top of the page so it remains constantly visible even
when the page is scrolled.

Refer to:
fixed.html
&
fixed.css

	Floating Content Boxes
The CSS float property allows a content box to be positioned at the side
boundary of its containing element – using the left or right keywords to
specify the preferred side. Typically this feature is used to flow text
around images that have been floated to the side of a containing
paragraph element.
You can also explicitly prevent text flowing alongside a floated content
box using the CSS clear property – specifying left, right, or both
keywords to determine which side must be clear, so that text will begin
below the floated content box.

Refer to:
float.html
&
float.css

	Clipping & Handling Overflow
Although CSS provides many controls to specify the precise size and
position of content boxes there is no guarantee that their content will
fit neatly within their boundaries in all circumstances. For example,
consider the effect of increasing the font size of text content that fits
snugly within a block-level content box – the text will then "overflow"
outside the box boundaries.
Overflowing content is generally visible by default, but the CSS
overflow property can specify alternative handling behaviors using the
hidden or scroll keywords.
Conversely, the content within absolutely-positioned block-level content
boxes can be cropped using the clip property – the rectangular section
to remain visible being identified by the coordinates of its corner
points. In CSS these coordinates are assigned to the clip property as a
comma-separated list within the parentheses of the special rect()
keyword, always in the order of top-left, top-right, bottom-right,
bottom-left.

Refer to:
overflow.html
&
overflow.css

	Constructing Columns
Traditionally, web page authors have used HTML tables to control how
page content is laid out by creating a borderless grid of cells into
which components of the page are placed. This method works well enough
for general layout but lacks the precise control offered by CSS. For
example, the absolute positioning scheme allows components to be
positioned easily with pinpoint accuracy but this could not be achieved
easily using tables. Thus CSS provides a superior layout method so web
page authors are now discouraged from using HTML tables for this purpose.
Moving to page layout with CSS invariably raises questions of how best
to control the page content. The following example suggests one way to
create a common page layout featuring a header and footer plus three
content columns.

Refer to:
columns.html
&
columns.css

	Summary
(o) A margin : auto rule horizontally centers block-level content boxes,
acting much like the old HTML <center> tag.
(o) A text-align : center rule horizontally centers text within a
content box.
(o) The absolute, relative, and fixed positioning schemes use the top,
right, bottom, and left properties to specify position.
(o) A position : absolute rule removes an element from the normal flow
layout and positions it at a specified distance from the boundaries of
its containing element.
(o) The stacking order of overlapping elements can be specified by
assigning integer values to their z-index property.
(o) A position : relative rule moves an element from the position it
would occupy in the normal flow layout and preserves the space it would
have occupied.
(o) A position : fixed rule removes an element from the normal flow
layout and positions it at a specified distance from the boundaries of
the viewport.
(o) The float property accepts left, right, or both keywords to
reposition an element within the normal flow layout and fill the space
it would have occupied with content.
(o) The clear property accepts left, right, or both keywords to
explicitly prevent text flowing alongside a floated content box.
(o) Overflowing content is visible by default but the overflow property
can accept hidden or scroll keywords to specify alternative behavior.
(o) The clip property accepts the rect() keyword that specifies the
coordinates of a clipping area within its parentheses.
(o) Web page authors are now discouraged from using HTML tables for
layout as CSS provides a superior layout method.

Chapter 5: Formatting Text
	Suggesting a Font
	Specifying Font Size
	Adjusting Font Weight
	Varying Font Styles
	Using the Font Shorthand
	Aligning Text
	Indenting & Spacing Text
	Decorating Text
	Governing Space & Direction
	Summary

	Suggesting a Font
A CSS style rule can suggest a specific font to be used by the browser
for the display of text content in a selected element by specifying the
font name to its font-family property. The browser will use the
specified font if it is available on the user's system – otherwise it
will display the text using its default font.
The default font may not be the best choice for the author's purpose so
CSS additionally allows the font-family property to suggest a generic
font family from those in the table below:
Font Family:	Description:							Example :
serif			Proportional fonts where characters		Times New Roman
				have different widths to suit their
				size, and with serif decorations
				at the end of the character strokes

sans-serif		Proportional fonts without serif		Arial
				decorations

monospace		Non-proportional fonts where			Courier
				characters are of fixed width,
				similar	to type-written text

cursive			Fonts that attempt to emulate human		Comic Sans
				hand-written text

fantasy			Decorative fonts with highly graphic	Castellar
				appearance

Develop the habit of enclosing all named fonts within quotes.
The browser will first try to apply the named font but in the event that
it is unavailable will select a font from those available that most
closely matches the characteristics of the generic preference. In this
way the appearance of the text should at least approximate the author's
intention, even without specific font-matching.
In a style rule font-family declaration the preferred font name should
appear before the generic font family preference separated by a comma.
Multiple named fonts can be specified as a comma-separated list – all
before the generic font family preference. Font names that include
spaces must be enclosed within quotes or they will not be recognized by
the browser.

Refer to:
fontfamily.html
&
fontfamily.css

	Specifying Font Size
CSS provides a number of ways to specify the size of text in a style
rule declaration by assigning values to the font-size property. The most
obvious is as an absolute size using any of the absolute units listed on
page 42. For example, as a 12pt size like this:
#text-1 {
	font-size: 12pt
	}
Additionally CSS provides the keywords xx-small, x-small, small, medium,
large, x-large, and xx-large to specify an absolute size:
Keyword:	Equivalent:
xx-large	24pt
x-large		17pt
large		13.5pt
medium		12pt
small		10.5pt
x-small		7.5pt
xx-small	7pt
Here the medium size is determined by the browser's default font size
then the rest are computed relative to that size.
Where the default size is equivalent to 12pt the computed values might
look something like those in the table on the left.
So a style rule might specify a font size one scale higher than the
default font size like this:
#text-2 {
	font-size: large
	}
Declarations may also specify a font size one scale higher or lower
using the larger and smaller keywords like this:
#text-3 {
	font-size: larger
	}
Use relative values rather than absolute values to specify font sizes
for maximum flexibility.
Alternatively font size can be specified as a relative size using any of
the relative units listed on page 42. For example, double
the inherited size (or default size if none is inherited) like this:
#text-4 {
	font-size: 2em
	}
Similarly, font size can be specified as a relative size stated as a
percentage. For example, as five times the inherited or default size
with a style rule declaration like this:
#text-5 {
	font-size: 500%
	}

Refer to:
fontsize.html
&
fontsize.css

	Adjusting Font Weight
The thickness or "weight" of text can easily be adjusted using the CSS
font-weight property and the bold and normal keywords.
Specifying a bold value to a selected element's font-weight property
causes normally-weighted text to appear in a heavier font and specifying
a normal value causes heavily-weighted text to appear in a lighter font.
In actuality the browser uses two different fonts to achieve this effect
– for normal text it uses a regularly-weighted font (for example
"Verdana") but it switches to the heavier-weighted variant of that font
if one is available (such as "Verdana Bold") for bold text.
The font-weight numeric values do not need to specify a unit type
because they are effectively keywords.
As an alternative to the bold and normal keywords a font weight can be
specified as a numeric value from 100-900, by hundreds. A font-weight
value of 400 is equivalent to normal weight and a value of 700 is
equivalent to bold weight.
It is intended that this numeric weighting system should allow for font
variants other than the normal and bold ones to be allotted to
intermediate values. For example, a font lighter than the normal font
(say, "Verdana Light") could equate to the weight value 300. Similarly,
a font heavier than the bold font (say, "Verdana Bold Black") could
equate to the numeric weight value 800.
In practice, however, the numeric system typically uses the normal font
for values of 100, 200, 300, 400, 500 and the bold font for values of
600, 700, 800, 900.
CSS also provides the keywords bolder and lighter for the purpose of
moving up or down the font-weight ladder by single steps – but where the
browser only recognizes two fonts, one for normal text and the other for
bold text, these simply have the same effect as the normal and bold
keywords.

Refer to:
fontweight.html
&
fontweight.css

	Varying Font Styles
Slanting Text:
A CSS font-style property can request the browser to use a slanting
variant of the current font by specifying the italic or oblique keywords
– these are subtly different. When the italic keyword is specified the
browser seeks an italicized variant of the current font in its font
database. This is an actual font set, similar to the current upright
font but graphically different to produce slanting versions of each
upright character. When the oblique keyword is specified the browser
seeks an oblique variant of the current font in its font database. This
may be an actual font set, a slanting version of the current upright
font, or alternatively it may be a generated version in which the
browser has computed a slanting version of the upright font. Either may
be mapped to the oblique keyword in the browser font database and called
upon by the CSS font-style property. In reality using either italic or
oblique keywords typically produces the same italicized text appearance,
and in each case upright text can be resumed by specifying the normal
keyword to the element's font-style property.
Specify the small-caps value to the font-variant property of heading
elements to make document headings more interesting.
Small Capitals:
A CSS property called font-variant can specify a small-caps value to
allow text characters to be displayed in a popular format using
uppercase characters of two different sizes. Uppercase text in the
selected element will appear as large capital characters but lowercase
text will appear as smaller capitals. The browser may achieve this
effect using a smaller capital from the font set, or by generating a
computed smaller version. Once again regular text can be resumed by
specifying the normal keyword as the font-variant.

Refer to:
fontstyle.html
&
fontstyle.css

	Using the Font Shorthand
Usefully CSS provides a font property to which various font preferences
can be specified in a combined single rule stating:
font-style | font-variant | font-weight | font-size | font-family
Appropriate values can be assigned to each part of the combined font
shorthand property. For example, like this:
p {font: italic small-caps bold medium "Times", serif}
Remember that a normal value is applied for each part of a combined font
rule unless explicitly specified – and this will override the current
parent element value.
The first three values for the font-style, font-variant, and font-weight
properties may appear in any order. Optionally values for each one of
these properties may be completely omitted and a normal value will be
automatically assumed.
It is important to recognize that values not explicitly specified will
still have a normal value applied – no value is inherited from the
containing element, and this can produce some unexpected results. For
example, a style rule selecting a span element within a containing
paragraph element styled by the rule above might look like this:
span {font: large cursive}
The values explicitly specified in this rule will be applied to the
font-size and font-family properties of the span element, and a normal
value will be applied to its font-style, font-variant, and font-weight
properties – so text within the span element does not inherit the italic,
small-caps, or bold values from the paragraph.
One further possibility available with a combined font rule is the
option to specify a line-height (the spacing between each line) by
adding a forward slash and unit value after the font-weight value. This
is useful to establish a common standard line spacing where various font
sizes appear.

Refer to:
font.html
&
font.css

	Aligning Text
English language text in a paragraph is normally horizontally aligned to
the left edge of the paragraph and this is the default behavior to
display text in a paragraph element's content box.
Additionally CSS provides a text-align property that can explicitly
specify how text should be aligned horizontally within the paragraph
element's content box using the keywords left, center, right, or justify.
As expected the left value aligns each line to the paragraph's left edge,
the right value aligns each line to the paragraph's right edge, and the
center value aligns each line centrally between both edges.
The text-align property only controls alignment of text within a content
box – it is not used to center content boxes.
Perhaps more interestingly the justify value aligns each full line to
both left and right edges of the content box and adjusts the spacing
between characters and words to make each line the same length.
In displaying lines of text the browser automatically computes the line
height to suit the content size – typically this will be the height of
the font × 1.2. The browser then displays the text centered vertically
in invisible "line boxes" of the computed height.
The CSS vertical-align property can explicitly specify how text should
be aligned vertically using the keywords baseline, sub, and super. The
baseline value specifies central vertical alignment, the default
behavior. The sub and super values increase the boundaries of the outer
container in which the line box exists and shift the text down or up
respectively to display subscript or superscript.
Content can also be shifted up or down by specifying positive or
negative unit values, or percentage values, to the verticalalign
property. Alternatively the top, middle, and bottom keywords can specify
vertical alignment with top-most, middle, or bottom-most content.
Usually subscript and superscript is much smaller than the text – create
the vertical shift by specifying sub or super values then apply a font
rule to reduce the shifted text's size.
Two other keywords of text-top and text-bottom can be specified to the
vertical-align property in order to vertically align other inline
content boxes, such as those of image elements, to the top or bottom
edge of a line box.

Refer to:
align.html
&
align.css

	Indenting & Spacing Text
One of the most common features of printed text is the indentation of
the first line of each paragraph to improve readability.
This can easily be accomplished for text in HTML paragraphs using the
text-indent property to specify an indentation size, such as 5em.
Alternatively the indentation value may be specified as a percentage
where the browser will indent an amount relative to the total line
length. For example, given a paragraph element within a "div" container
element of 500px width, specifying a textindent value of 10% would
indent the start of the first line by 50px (500 × 10% = 50).
The word-spacing and letter-spacing properties can both accept negative
values – to produce some interesting results.
It is also possible to specify negative values for the text-indent
property but this can produce inconsistent results so is best avoided.
The amount of space between each word can be adjusted from the normal
default spacing by explicitly specifying a value to the CSS word-spacing
property. Note that the specified value is added to the default spacing
to increase the space. For example, specifying a unit value of 5em
increases the space to normal + 5em, not a spacing of 5em overall.
Similarly the amount of space between each letter can be adjusted from
the normal default spacing by explicitly specifying a value to the CSS
letter-spacing property. This also adds the specified value onto the
default spacing to determine the total space. For example, specifying a
unit value of 5em increases the space to normal + 5em, not a spacing of
5em overall.
Both word-spacing and letter-spacing properties accept the normal
keyword to resume normal spacing. Also they may both be overridden by
the text-align property, described on the previous page, that has
precedence in determining the appearance of the entire line.

Refer to:
space.html
&
space.css

	Decorating Text
Style rules can add decorative lines to text content using the CSS
text-decoration property with keywords underline, overline, and
line-through. These behave as expected adding a line below, a line above,
and a line through the text respectively.
The blink keyword may also be specified to the text-decoration property
to cause the browser to repeatedly hide then display the text, blinking
it on and off.
Some users may not recognize hyperlinks if their default underline is
removed.
More usefully, the CSS none keyword can be specified to the
text-decoration property to prevent unwanted decorations appearing –
this is particularly popular for displaying hyperlinks without their
usual default underline.
Multiple keywords can be specified to the text-decoration property as a
space-separated list to apply multiple decorations to the text.
An additional way to enhance text with CSS is available using the
text-transform property to specify capitalization in the selected
element with the keywords uppercase, lowercase, or capitalize.

Refer to:
decor.html
&
decor.css

	Governing Space & Direction
The default treatment of whitespace within text content is to collapse
multiple spaces into a single space, but this can be controlled with the
CSS white-space property. Specifying the pre keyword preserves all
spaces as they appear in the original text, including any line breaks.
Conversely, the automatic wrapping of text in a block can be prevented
by specifying the nowrap keyword. Additionally the pre-wrap keyword can
be specified to preserve spaces while still allowing text to wrap
normally, or the pre-line keyword can be specified to collapse multiple
spaces while preserving line breaks.
You can discover more about Unicode online at www.unicode.org and more
on character entities at www.w3.org.
The default left-to-right direction of text lines can be changed to
right-to-left by specifying the rtl keyword to the CSS direction
property and the normal direction resumed with the ltr keyword.
Interestingly, when the line direction is changed with the rtl keyword
the words appear from right-to-left but the order of English language
characters is preserved so that each word still reads correctly
left-to-right.
This intelligent feature also allows text to be presented in different
directions on a single line. For example, to incorporate words in
languages that are read right-to-left such as Hebrew and Arabic. The
browser examines the Unicode value of each character using a complex
BiDirectional algorithm to determine which direction each word should be
displayed – those characters from right-to-left languages are
automatically displayed in that direction, even if written logically
from left-to-right in the HTML source code. The automatic BiDirectional
algorithm can be turned off however by specifying the bidi-override
keyword to a unicode-bidi property.

Refer to:
direction.html
&
direction.css

	Summary
(o) The font-family property can suggest specific fonts by name and also
specify a generic font family as serif, sans-serif, monospace, cursive,
or fantasy.
(o) Font size can be specified using keywords such as large, absolute
sizes such as 12pt, or relative sizes such as larger.
(o) Thickness of text can be specified to the font-weight property using
keywords such as bold, or numeric values such as 700.
(o) Slanting text can be created by specifying the italic or oblique
keywords to the font-style property.
(o) Specifying a small-caps value to the font-variant property causes
lowercase characters to appear as small capital letters.
(o) The font shorthand property can be used to specify values for the
font-style, font-variant, font-weight, font-size, and font-family
properties rather than individual rules.
(o) The font-weight property may also specify a line-height by adding a
forward slash and unit size after the weight value.
(o) Horizontal position of text within a content box can be specified to
the text-align property by keywords such as center.
(o) Vertical inline position of text can be specified to the
vertical-align property using keywords such as super.
(o) The text-indent property allows the start of each paragraph to be
indented by a specified distance.
(o) Text spacing can be adjusted by the word-spacing and letter-spacing
properties.
(o) Lines can be added to text by the text-decoration property and the
case can be specified to the text-transform property.
(o) Specifying pre to the white-space property preserves spacing
(o) The direction property can control text direction but can be
overridden by the unicode-bidi property.

Chapter 6: Arranging Data
	Setting Table Columns
	Spacing Table Cells
	Collapsing Table Borders
	Assigning Table Features
	Choosing List Markers
	Positioning List Markers
	Summary

	Setting Table Columns
Although web page authors are now discouraged from using HTML tables for
page layout (in favor of CSS) tables remain an invaluable format for the
presentation of information within the content of a page.
When displaying an HTML table the browser will, by default, automatically
create a table layout sized to accommodate its content. This invariably
produces a table with columns of varying width where each column width is
determined by the widest content of any cell in that column. This process
requires the browser to examine the table content in some detail before
it can compute the optimum table layout and, especially for large tables,
can take some time before the browser is able to draw the table.
The caption-side property can suggest where a caption might appear but
the actual treatment of captions is browser-specific.
CSS provides an alternative that allows the browser to quickly compute a
suitable table layout without examining the content of the entire table –
a fixed-layout can be specified to the table-layout property of a table
element with the fixed keyword.
In a fixed layout the browser need only consider the width value of the
table itself and the width value of the columns and cells on its first
row to determine the table layout like this:
The overall table width will be its specified width value or the sum of
its column width values – whichever is the greater.
A specified column width value sets the width for that column.
When there is no specified column width value a specified cell width
value sets the width for that column.
Any columns that have no specified width values, for either column or
cell, will be sized equally within the table width.
Specify the first column width and a fixed layout rule to create a first
column of custom width and other columns of equal width to each other.
Alternatively a style rule can explicitly specify that the default table
layout scheme should be used, in which the browser computes the column
widths according to their content, by assigning an auto value to the
table-layout property.
Where tables include a caption element the position of the caption can be
suggested by specifying keywords of top or bottom to the table element's
CSS caption-side property.

Refer to:
table.html
&
table.css

	Spacing Table Cells
The distance between table cell borders can be specified as a unit value
to the CSS border-spacing property. This easily allows cells to be spread
some distance apart throughout a table.
A single specified border-spacing value will be applied uniformly to all
cell separations – in much the same way as with the HTML cellspacing
attribute.
CSS provides greater flexibility, however, by allowing two values to be
specified to the border-spacing property as a spaceseparated list. The
first will be applied to the horizontal spacing, at the left and right of
each table cell, and the second will be applied to the vertical spacing
at the top and bottom of each cell. This means that different distances
can be specified for the horizontal and vertical spacing throughout a
table.
Another possibility offered by CSS is the ability to hide table cells
that contain no content. These frequently occur due to the grid format of
tables, which does not always conveniently match the number of cells
required. For example, displaying nine content items in a table of five
rows and two columns.
Creating a style rule with the CSS empty-cells property specifying a hide
value will cause the browser to not display the border and background of
any cell that contains absolutely no content. Cells that contain any
content at all, even if it's simply a &nbsp; (nonbreaking space entity)
will still be visible.
Conversely a style rule can explicitly ensure that empty cells are
displayed by specifying a show value to the empty-cells property.
Older versions of Internet Explorer, prior to IE8, do not support the
border-spacing property.
Empty cells that are hidden do continue to have a presence in the table
layout in as much as their border-spacing values are preserved. For
example, where the border-spacing property is set to 20px, and the
empty-cells property specifies a hide value, a single empty cell is not
displayed but the surrounding cells remain 40 pixels apart – rather than
just a distance of 20 pixels that would exist if the hidden cell did not
exist.

Refer to:
hide.html
&
hide.css

	Collapsing Table Borders
The borders of adjacent table borders, and table cell borders, can be
made to "collapse" into a single border by specifying the collapse
keyword to the CSS border-collapse property. This requires the browser to
perform a series of evaluations, comparing the existing borders, to
determine how the collapsed border should appear:
	Visibility Evaluation: where one of the borders to be collapsed has a
		border-style value of hidden, that value takes precedence – so the
		collapsed border at that location will be hidden.
	Width Evaluation: where two visible borders with different
		border-width values are to be collapsed, the highest value takes
		precedence – so the collapsed border will be the greater width.
	Style Evaluation: where two visible borders of equal width are to be
		collapsed, their border-style value sets the precedence in the
		descending status order of double, solid, dashed, dotted, ridge,
		outset, groove, inset – so the collapsed border at that location
		will be in the style of highest status. For example, a double
		style wins out over a solid style.
	Color Evaluation: where two visible borders of equal width and
		identical style are to be collapsed, the border-color value is
		determined in the descending status order of cell, row, row
		group, column, column group, table – so that collapsed border
		will be in the color of highest status. For example, the cell
		border-color wins out over the table border-color value.
The separate keyword can also be specified to the border-collapse
property – to explicitly prevent collapsing borders.
The effect of collapsing borders where a table border-width of 2px is
compared to a cell border-width of 5px means that the collapsed
border-width will be 5 pixels – the greater width.
In comparing adjacent border-style values of dotted and double, the
collapsed border-style will be double – the higher status.
Similarly, comparing adjacent border-style values of dotted and solid,
the collapsed border-style will be solid – the higher status.

Refer to:
collapse.html
&
collapse.css

	Assigning Table Features
The CSS display property can accept a range of values to specify that a
selected element should be treated as a table component – emulating the
default behavior of HTML tags that a browser automatically applies to
table components:
HTML Tag	CSS Equivalent
<table>		table
<tr>		table-row
<thead>		table-header-group
<tbody>		table-row-group
<tfoot>		table-footer-group
<col>		table-column
<colgroup>	table-column-group
<th>		table-cell
<td>		table-cell
<caption>	table-caption
The CSS values that can be specified to the display property are listed
in the table above together with the HTML tag they most closely represent.
These can be used to specify table features to elements of an XML
document so a browser will display their content as if it was an HTML
table.

Refer to:
xtable.xml
&
xtable.css

	Choosing List Markers
A list "marker" indicates the beginning of an item in a list – typically
a bullet in an unordered <ul> list, or an incrementing number in an <ol>
ordered list. The browser conducts an item count in each case but usually
only uses this to number the items in an ordered list display.
The CSS list-style-type property can specify an alternative type of
marker for any list – so unordered lists can have numbered markers and
ordered lists can have bullet-points if so desired.
Keywords allow the bullet marker type to be specified as disc, circle, or
square, and number marker types as lower-roman, upper-roman, decimal, or
decimal-leading-zero.
Alphabetical marker types can be specified with the lower-latin,
upper-latin, and lower-greek keywords. Additionally the CSS specification
provides keywords for other alphabets such as armenian and georgian – but
a suitable font is needed for the marker to be displayed correctly by the
web browser.
The list-style-type property can also specify a none value to explicitly
suppress the markers so they will not be displayed, although they do
remain in the item count.
Optionally an image may be specified as a marker by stating its path in
the parentheses of a url() value to the list-style-image property.

Refer to:
markers.html
&
markers.css

	Positioning List Markers
Typically, to display a list the browser creates a block-level content
box for the entire list and inline content boxes for each list item.
Typically, a left margin insets the list item content boxes and each
marker appears up against the right edge of this margin area – outside
the list item content boxes.
The position of the marker may be explicitly specified to the
list-style-position property using inside or outside keywords to determine
whether the markers should appear inside the list item content boxes.
Rather than creating separate style rules for the list-style-type,
list-style-image, and list-style-position properties it is simpler to use
the CSS shorthand technique that may specify a value for each property as
a space-separated list to the liststyle property. The values may appear
in any order and where any value is omitted the default value for that
property will be assumed.
Lists of either type may be nested with their marker position and type
specified independently.

Refer to:
list.html
&
list.css

	Summary
(o) When the table-layout property specifies a fixed layout the browser
need only assess the width value of the table and the width of the cells
on its first row so it can quickly draw the table.
(o) The caption-side property can specify whether the table caption
should appear at the top or bottom of the table.
(o) A border-spacing property can specify the distance between table cell
borders.
(o) Cells containing absolutely no content can be hidden by specifying a
hide value to the empty-cells property.
(o) Adjacent borders of a table and its cells can be combined into a
single border by specifying the collapse keyword to the border-collapse
property.
(o) The display property can specify that a selected element should be
treated by the browser as a table component using table, table-row,
table-header-group, table-row-group, table-cell, table-footer-group,
table-column, or tablecaption keywords.
(o) A list-style-type property can specify the type of bullet marker to
be used for list items with disc, circle, or square keywords.
(o) The list-style-type property can specify that each list item should
have numerical markers using the lower-roman, upper-roman, decimal, or
decimal-leading-zero keywords.
(o) Alphabetical list markers can be specified to the list-style-type
property as lower-latin, upper-latin, or lower-greek.
(o) An image can be used as a list marker by stating its path in the
url() value specified to the list-style-image property.
(o) Specifying a value of inside or outside to the list-style-position
determines whether markers appear inside the content box.
(o) The list-style property can specify the individual list-style-type,
list-style-image, and list-style-position properties as CSS shorthand.

Pre-Assessment
Pt is a measurement that is 1/72 of an inch or 0.35mm.

The grid system is a series of columns and rows.
Grids are organised within a parent container or wrapper.

Absolute positioning positions an element based on its parent element,
whereas an element that has a position of fixed is positioned in relation
to the browser window.

The overflow property is used to control how text flows on a webpage.

The display property is used to set objects inline with each other as
items fit on a webpage.

Red is the default hyperlink color for an active hyperlink.

Word spacing sets the space between words whereas letter spacing sets
the space between characters in words.

Lab Exercise
To view the position type of an element, users should ensure that the
correct element is selected, and then they can view its details under
the Computed tab:
Select <div id = "blue">_</div>
Select the Computed Tab

Post-Assessment
Q1: Using the float:left property and value will move an element as far
	left as it can be placed relative to other elements on a webpage.
Q2: Which is true of block elements?
	They are stationary and they can position themselves alongside
	other elements: x
	They span the full width of a page and they render their own lines: v
	Block elements render the full width of a page and will always render
	on their own lines, inline elements take up the necessary space
	required, and can position themselves alongside other elements.
Q3: Line-height property sets the height of individual lines within a(n):
	form field: x
	element: v
Q4: Which word wrap property keeps long text wrapped inside its container?
	Long-text: x
	Break-word: v
Q5: .backimage {
		background-image: url(Images/Kazoo-transparent.jpg)
		}
	<body class = "backimage">
Q6: Which is one use of a div tag?
	Separate webpage objects: x
	Control the width of an entire webpage: v
Q7: The @media rule is used to set a group of styles for a desired
	screen width or media state:
	@media only screen and (max-width:500px) {
	body {
		background-color: white;
		}
	}
Q8: The max-width element can be used to remedy which scenario?
	A table that does not fit on a smartphone: x
	A fluid measurement that looks awkward on a screen with a very
	large resolution: v

eCollege T5 Quiz:
Q1: float: left max; x
	float: left; v

Q15: The block property is used to set objects inline with each other as
	 items fit on a webpage. x
	 The display property ... v

Q21: text-decoration: No-underline; x
	 text-decoration: None; v

Q25: Which is one use of a div tag?
	 Separate webpage objects. x
	 Control the width of an entire webpage. v

eCollege CSS Quiz (26/40 Marks, 65%/70%):
		-14 Marks (+2 Extra Marks to Reach 70%)
		Reattempt Quiz on eCollege @ Mon 3rd Apr 2023 after 11:13am
Q2 (-1): img {float: left;} x
		img {float: none;} v

Q3 (-1): .div2 {float: left;} x
		.div2 {clear: left;} v

Q4 (-0.5): .div1 {float: right;} v
	.div2 {float: left;} x
		.div2 {clear: right;} v

Q6 (-0.5): Horizontally center the first div element in the web page.
    Center align the text in the second div element in the web page.
		div.a {text-align: justify;} x
			div.a {margin: auto;} v
		div.b {text-align: center;} v

Q13 (-1): internal takes precedence over inline style sheets. x
		inline takes precedence over internal style sheets. v

Q14 (-1): The p element will be formatted in navy. x
		The p element will be formatted in red. v
	 The h1 element will be formatted in black. x
		The h1 element will be formatted in white. v
	 The h2 element will be formatted in red. x
		The h2 element will be formatted in blue. v

Q17 (-1): All content should be visible, no matter how small the browser window.
		div.ex {width: 300px;} x
			div.ex {max-width: 300px;} v

Q19 (-1): Add scrollbars to div, only when necessary (when content overfills the container).
		overflow: scroll; x
			overflow: auto; v

Q23 (-1): 2nd paragraph indented by 5em.
		text-indent: 5em; x
			padding-left: 5em; v

Q29 (-0.3): Why should a developer test a website using different browsers?
		Not all browsers will display a website in the same way. v
		Website visitors should have a positive user experience, no matter what device and browser they are using. v
		MISSING = To grow your audience.

Q31 (-1): Which div element will overflow their contents (if any)?
		Neither of the div elements. x
			The div element with the class = "b" selector. v

Q32 (-1): How will the text, 'Launching in Ireland on the 7th February 2019!' appear in the web page?
		The text will appear within a border. The color of the top and bottom borders will be yellow. The color of the left and right borders will be black. x
			The text will appear without any border around it. v

Q33 (-0.5): Which of the following could be used to create a responsive web page?
		CSS v
		JavaScript v
		MISSING = HTML v
		MISSING = jQuery v

Q34 (-1): What will be the color of the header, when the html file shown below, is rendered in a browser?
		navy x
			red v

Q35 (-1): What will be the color of the header, when the html file shown below, is rendered in a browser?
		navy x
			fuchsia v

Q39 (-1): T or F: The position of the third div element will appear directly after the first div element.
		False x
			True v

eCollege CSS Quiz (26/40 Marks, 65%/70%):
		-14 Marks (+2 Extra Marks to Reach 70%)

Q4 (-0.5): .div1 {float: right;} v
	.div2 {clear: left;} x
		.div2 {clear: right;} v

Q7 (-0.5): div.a {padding-top: .5em;} x
				div.a {padding: .5em;} v
		   div.b {padding: .5em;} x
				div.b {padding-top: .5em;} v

Q18 (-1): All content should be visible, no matter how small the browser window:
			position: relative; x
				position: fixed; v

Q38 (-1): T or F: The position of the third <div> element will move relative to the position of the second <div> element.
			True x
				False v

Q39 (-1): T or F: The position of the third div element will appear directly after the first div element.
		False x
			True v